{
  "types": [
    {
      "name": "ConditionalMiddleware",
      "doc": "ConditionalMiddleware is an alias to middleware.ConditionalMiddleware,\nwhich pairs a pattern (e.g., \"/api/*\") with a Middleware function.\n",
      "package": "falcon",
      "code": "type ConditionalMiddleware = middleware.ConditionalMiddleware"
    },
    {
      "name": "Context",
      "doc": "Context is an alias to server.Context, which wraps the request and response\nwriter and provides convenience methods (params, body parsing, etc.).\n",
      "package": "falcon",
      "code": "type Context = server.Context"
    },
    {
      "name": "Group",
      "doc": "Group represents a collection of routes that share a common path prefix\nand middleware stack. Useful for organizing related endpoints like `/api/v1/*`.\n",
      "methods": [
        {
          "name": "DELETE",
          "doc": "DELETE registers a route with the HTTP DELETE method for this group.\nThe handler is invoked when a request matches the given path.\n",
          "code": "func (g *Group) DELETE(path string, handler HandlerFunc)"
        },
        {
          "name": "GET",
          "doc": "GET registers a route with the HTTP GET method for this group.\nThe handler is invoked when a request matches the given path.\n",
          "code": "func (g *Group) GET(path string, handler HandlerFunc)"
        },
        {
          "name": "Handle",
          "doc": "Handle registers a route for the group with a specific HTTP method and path.\nIt automatically prepends the group's prefix to the path and applies\nthe group's middleware stack in reverse order for correct execution.\n",
          "code": "func (g *Group) Handle(method, path string, handler HandlerFunc)"
        },
        {
          "name": "PATCH",
          "doc": "PATCH registers a route with the HTTP PATCH method for this group.\nThe handler is invoked when a request matches the given path.\n",
          "code": "func (g *Group) PATCH(path string, handler HandlerFunc)"
        },
        {
          "name": "POST",
          "doc": "POST registers a route with the HTTP POST method for this group.\nThe handler is invoked when a request matches the given path.\n",
          "code": "func (g *Group) POST(path string, handler HandlerFunc)"
        },
        {
          "name": "PUT",
          "doc": "PUT registers a route with the HTTP PUT method for this group.\nThe handler is invoked when a request matches the given path.\n",
          "code": "func (g *Group) PUT(path string, handler HandlerFunc)"
        },
        {
          "name": "Use",
          "doc": "Use registers a middleware for this specific group.\nThese middlewares are applied only to routes within the group,\nin addition to any global middleware from the parent server.\n",
          "code": "func (g *Group) Use(mw middleware.Middleware)"
        }
      ],
      "package": "falcon",
      "code": "type Group struct {\n\t// Prefix is the base path for this group (e.g., \"/api/v1\").\n\tPrefix\tstring\n\n\t// Server is a reference back to the parent server, allowing\n\t// groups to register routes directly into the main router.\n\tServer\t*Server\n\n\t// Middlewares is a list of middleware that will be applied to\n\t// every route registered within this group, in addition to any\n\t// global or conditional middleware from the Server.\n\tMiddlewares\t[]middleware.Middleware\n}"
    },
    {
      "name": "HandlerFunc",
      "doc": "HandlerFunc is an alias to server.HandlerFunc, the function signature\nthat route handlers must implement. It takes a *Context and returns a *Response.\n",
      "package": "falcon",
      "code": "type HandlerFunc = server.HandlerFunc"
    },
    {
      "name": "Middleware",
      "doc": "Middleware is an alias to middleware.Middleware, representing a function\nthat wraps and modifies a HandlerFunc, similar to how middleware works\nin frameworks like Express or Fiber.\n",
      "package": "falcon",
      "code": "type Middleware = middleware.Middleware"
    },
    {
      "name": "Response",
      "doc": "Response is an alias to server.Response, the unified return type\nfrom every handler function. Encoded as JSON and written to the client.\n",
      "package": "falcon",
      "code": "type Response = server.Response"
    },
    {
      "name": "Server",
      "doc": "Server is the main entry point for the Falcon framework.\nIt holds the router, global middlewares, and any conditional middlewares\nthat should be applied based on route patterns.\n",
      "methods": [
        {
          "name": "DELETE",
          "doc": "DELETE registers a route with the HTTP DELETE method on the server.\nThe handler is invoked when a request matches the given path.\n",
          "code": "func (s *Server) DELETE(path string, handler server.HandlerFunc)"
        },
        {
          "name": "GET",
          "doc": "GET registers a route with the HTTP GET method on the server.\nThe handler is invoked when a request matches the given path.\n",
          "code": "func (s *Server) GET(path string, handler server.HandlerFunc)"
        },
        {
          "name": "Group",
          "doc": "Group represents a collection of routes sharing a common prefix\nand middleware stack. Useful for organizing related endpoints.\nExample: v1 := app.Group(\"/api/v1\")\n",
          "code": "func (s *Server) Group(prefix string) *Group"
        },
        {
          "name": "Handle",
          "doc": "Handle registers a route with a specific HTTP method and path.\nGlobal middleware is automatically applied in reverse order (so execution order is correct).\n",
          "code": "func (s *Server) Handle(method, path string, handler server.HandlerFunc)"
        },
        {
          "name": "PATCH",
          "doc": "PATCH registers a route with the HTTP PATCH method on the server.\nThe handler is invoked when a request matches the given path.\n",
          "code": "func (s *Server) PATCH(path string, handler server.HandlerFunc)"
        },
        {
          "name": "POST",
          "doc": "POST registers a route with the HTTP POST method on the server.\nThe handler is invoked when a request matches the given path.\n",
          "code": "func (s *Server) POST(path string, handler server.HandlerFunc)"
        },
        {
          "name": "PUT",
          "doc": "PUT registers a route with the HTTP PUT method on the server.\nThe handler is invoked when a request matches the given path.\n",
          "code": "func (s *Server) PUT(path string, handler server.HandlerFunc)"
        },
        {
          "name": "ServeHTTP",
          "doc": "ServeHTTP implements http.Handler, so Falcon Server can be passed\ndirectly to http.ListenAndServe. It finds the route, applies conditional middleware,\nexecutes the handler, and writes the Response as JSON.\n",
          "code": "func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request)"
        },
        {
          "name": "Start",
          "doc": "Start runs the HTTP server on the specified address. It logs the startup\nand will terminate the program if ListenAndServe returns an error.\n",
          "code": "func (s *Server) Start(addr string)"
        },
        {
          "name": "StartAutoTLS",
          "doc": "StartAutoTLS starts the server with automatic TLS certificate management using Let's Encrypt.\nThis method automatically obtains and renews TLS certificates for the specified domain\nusing the ACME protocol. The server will bind to port 443.\n\nParameters:\n  - domain: The domain name for which to obtain certificates (e.g., \"example.com\")\n\nThe method sets up:\n  - Automatic certificate cache in a local \"certs\" directory\n  - Automatic acceptance of Let's Encrypt Terms of Service\n  - Host whitelist policy for the specified domain\n  - TLS configuration with automatic certificate retrieval\n\nRequirements:\n  - The server must be accessible from the internet on port 443\n  - The domain must point to the server's IP address\n  - Port 80 should also be available for ACME challenges (handled automatically by autocert)\n\nThis method will call log.Fatal if the server fails to start, terminating\nthe program. Use this for production deployments where server startup\nfailure should halt the application.\n\nExample:\n\n\tserver := \u0026Server{}\n\tserver.StartAutoTLS(\"example.com\") // Will serve HTTPS on port 443\n",
          "code": "func (s *Server) StartAutoTLS(domain string)"
        },
        {
          "name": "StartAutoTLSWithStarter",
          "doc": "StartAutoTLSWithStarter starts the server with automatic TLS certificate management\nusing a custom TLS starter. This method provides the same automatic certificate\nfunctionality as StartAutoTLS but allows dependency injection of the server\nstartup mechanism, making it testable.\n\nParameters:\n  - domain: The domain name for which to obtain certificates (e.g., \"example.com\")\n  - starter: An implementation of TLSStarter interface that handles server startup\n\nThis method is primarily intended for testing purposes where you need to mock\nthe server startup behavior. For production use, prefer StartAutoTLS which\nuses the server's own startup mechanism.\n\nThe method configures:\n  - autocert.Manager with local certificate caching\n  - Automatic TOS acceptance for Let's Encrypt\n  - Host policy restricting certificates to the specified domain\n  - HTTP server bound to port 443 with TLS configuration\n\nExample:\n\n\tserver := \u0026Server{}\n\tmockStarter := \u0026MockTLSStarter{...}\n\tserver.StartAutoTLSWithStarter(\"example.com\", mockStarter)\n",
          "code": "func (s *Server) StartAutoTLSWithStarter(domain string, starter TLSStarter)"
        },
        {
          "name": "StartTLS",
          "doc": "StartTLS starts the server with TLS using the provided certificate and key files.\nThe server will bind to the specified address and serve HTTPS traffic.\n\nParameters:\n  - addr: The address to bind to (e.g., \":443\", \"localhost:8443\")\n  - certFile: Path to the TLS certificate file\n  - keyFile: Path to the TLS private key file\n\nThis method will call log.Fatal if the server fails to start, terminating\nthe program. Use this for production deployments where server startup\nfailure should halt the application.\n\nExample:\n\n\tserver := \u0026Server{}\n\tserver.StartTLS(\":443\", \"/path/to/cert.pem\", \"/path/to/key.pem\")\n",
          "code": "func (s *Server) StartTLS(addr, certFile, keyFile string)"
        },
        {
          "name": "Use",
          "doc": "Use registers a global middleware that will run on every request.\nMiddleware is executed in the order it is added.\nExample:\n\n\tserver.Use(middleware.CORS())\n",
          "code": "func (s *Server) Use(mw middleware.Middleware)"
        },
        {
          "name": "UseIf",
          "doc": "UseIf registers a conditional middleware that only runs if the request path\nmatches the given pattern. Patterns can include a wildcard '*' at the end.\nExample: UseIf(\"/api/v1/*\", AuthMiddleware())\n",
          "code": "func (s *Server) UseIf(pattern string, mw middleware.Middleware)"
        }
      ],
      "package": "falcon",
      "code": "type Server struct {\n\t// contains filtered or unexported fields\n}"
    },
    {
      "name": "TLSStarter",
      "doc": "TLSStarter defines an interface for starting a TLS server.\nImplementations should provide the startTLSServer method to handle\nthe server startup logic for HTTPS.\n",
      "package": "falcon",
      "code": "type TLSStarter interface {\n\t// contains filtered or unexported methods\n}"
    },
    {
      "name": "TemplateRenderer",
      "doc": "TemplateRenderer is an alias for server.TemplateRenderer.\nIt is responsible for rendering HTML templates within Falcon.\n",
      "package": "falcon",
      "code": "type TemplateRenderer = server.TemplateRenderer"
    },
    {
      "name": "CORSConfig",
      "doc": "CORSConfig defines configuration for Cross-Origin Resource Sharing (CORS).\nAllows specifying which origins, headers, and methods are permitted.\n",
      "package": "middleware",
      "code": "type CORSConfig struct {\n\tAllowOrigins\t[]string\t// Allowed origins, e.g., [\"https://example.com\"] or [\"*\"]\n\tAllowMethods\t[]string\t// Allowed HTTP methods, e.g., [\"GET\", \"POST\"]\n\tAllowHeaders\t[]string\t// Allowed headers, e.g., [\"Content-Type\", \"Authorization\"]\n}"
    },
    {
      "name": "CSRFConfig",
      "doc": "CSRFConfig defines configuration for CSRF protection middleware.\n",
      "package": "middleware",
      "code": "type CSRFConfig struct {\n\tTokenHeader\tstring\t\t\t\t\t\t// Header to read/write CSRF token\n\tTokenCookie\tstring\t\t\t\t\t\t// Cookie name to store the token\n\tContextKey\tstring\t\t\t\t\t\t// Context key for storing the token\n\tExpiry\t\ttime.Duration\t\t\t\t\t// Token expiration duration\n\tSecret\t\t[]byte\t\t\t\t\t\t// HMAC secret used for token validation\n\tSkipMethods\t[]string\t\t\t\t\t// HTTP methods that don't require validation (safe methods)\n\tErrorHandler\tfunc(*server.Context, error) *server.Response\t// Optional custom error handler\n\tCookieSecure\tbool\t\t\t\t\t\t// Whether the cookie is Secure\n\tCookieHTTPOnly\tbool\t\t\t\t\t\t// Whether the cookie is HttpOnly\n}"
    },
    {
      "name": "ConditionalMiddleware",
      "doc": "ConditionalMiddleware pairs a middleware with a path pattern.\nThe middleware is only applied if the request path matches the pattern.\nPatterns can include a wildcard '*' at the end to match any subpath.\n",
      "package": "middleware",
      "code": "type ConditionalMiddleware struct {\n\tPattern\t\tstring\t\t// The URL path pattern to match, e.g., \"/api/v1/*\"\n\tMiddleware\tMiddleware\t// The middleware function to apply when the pattern matches\n}"
    },
    {
      "name": "Middleware",
      "doc": "Middleware defines the function signature for all middleware in Falcon.\nA middleware wraps a HandlerFunc, allowing pre- or post-processing of requests.\nExamples include logging, authentication, profiling, or panic recovery.\n",
      "package": "middleware",
      "code": "type Middleware func(server.HandlerFunc) server.HandlerFunc"
    },
    {
      "name": "ValidationConfig",
      "doc": "ValidationConfig holds configuration for the validation middleware.\nAllows injecting a custom validator instance (from go-playground/validator/v10).\n",
      "package": "middleware",
      "code": "type ValidationConfig struct {\n\tValidator *validator.Validate\t// Optional custom validator. If nil, a new validator is created.\n}"
    },
    {
      "name": "Context",
      "doc": "Context wraps http.ResponseWriter and *http.Request, providing\nconvenience access to route parameters and helper methods in the future.\nFields:\n  - Writer: the http.ResponseWriter to write responses.\n  - Request: the incoming HTTP request.\n  - Params: a map of path parameters extracted from the route (e.g., \":id\").\n",
      "methods": [
        {
          "name": "Bind",
          "doc": "Bind reads the request body and decodes it into dest based on Content-Type.\nAutomatically writes a 400 Bad Request response if binding fails.\n",
          "code": "func (c *Context) Bind(dest any) error"
        },
        {
          "name": "BindForm",
          "doc": "BindForm parses form data and binds it to a map\nTakes only the first value for each key\n",
          "code": "func (c *Context) BindForm(dest map[string]string) error"
        },
        {
          "name": "BindFormAll",
          "doc": "BindFormAll parses URL-encoded form data and returns all values in a url.Values map.\n",
          "code": "func (c *Context) BindFormAll() (url.Values, error)"
        },
        {
          "name": "BindJSON",
          "doc": "BindJSON enforces JSON Content-Type and decodes into dest.\nAutomatically writes 400 response on error.\n",
          "code": "func (c *Context) BindJSON(dest any) error"
        },
        {
          "name": "BindXML",
          "doc": "BindXML enforces XML Content-Type and decodes into dest.\nAutomatically writes 400 response on error.\n",
          "code": "func (c *Context) BindXML(dest any) error"
        },
        {
          "name": "Blob",
          "doc": "Blob writes raw binary data with the given Content-Type and returns a Response\nExample: c.Blob(200, data, \"image/png\")\n",
          "code": "func (c *Context) Blob(code int, data []byte, contentType string) *Response"
        },
        {
          "name": "ErrorJSON",
          "doc": "ErrorJSON writes an error response as JSON with the provided status code.\nIf c.Handled is already true, it returns the Response without writing to the client.\n",
          "code": "func (c *Context) ErrorJSON(message string, details any, code int) *Response"
        },
        {
          "name": "File",
          "doc": "File serves a file from disk with proper Content-Type.\nIf file doesn't exist or can't be read, returns a 404/500 JSON response.\n",
          "code": "func (c *Context) File(filePath string) *Response"
        },
        {
          "name": "FormFile",
          "doc": "FormFile retrieves the file from a multipart form.\nIt returns the first file for the provided form key.\nExample: \u003cinput type=\"file\" name=\"avatar\" /\u003e -\u003e c.FormFile(\"avatar\")\n",
          "code": "func (c *Context) FormFile(name string) (multipart.File, *multipart.FileHeader, error)"
        },
        {
          "name": "FormValue",
          "doc": "FormValue returns the first value for the named component of the POST or PUT request body.\nIt calls ParseMultipartForm and ParseForm if necessary.\nExample: \u003cinput type=\"text\" name=\"username\" /\u003e -\u003e c.FormValue(\"username\")\n",
          "code": "func (c *Context) FormValue(name string) string"
        },
        {
          "name": "Get",
          "doc": "Get retrieves a value from the Context by key.\nReturns nil if the key does not exist.\nExample: user := c.Get(\"user\")\n",
          "code": "func (c *Context) Get(key string) any"
        },
        {
          "name": "HTML",
          "doc": "HTML writes HTML content and returns a Response\nExample: c.HTML(200, \"\u003ch1\u003eHello\u003c/h1\u003e\")\n",
          "code": "func (c *Context) HTML(code int, html string) *Response"
        },
        {
          "name": "JSON",
          "doc": "JSON writes the given Response object as JSON with the provided status code.\nThis method respects c.Handled, so it won't write twice if something else already wrote.\n",
          "code": "func (c *Context) JSON(success bool, message string, details any, code int) *Response"
        },
        {
          "name": "Param",
          "doc": "Param returns the value of a path parameter by name.\nExample: /users/:id -\u003e c.Param(\"id\") returns \"123\"\n",
          "code": "func (c *Context) Param(name string) string"
        },
        {
          "name": "Query",
          "doc": "Query returns the first value of a URL query parameter by key.\nExample: /search?q=golang -\u003e c.Query(\"q\") returns \"golang\"\n",
          "code": "func (c *Context) Query(key string) string"
        },
        {
          "name": "QueryArray",
          "doc": "QueryArray returns all values for a query parameter key.\nExample: /filter?tag=go\u0026tag=web -\u003e c.QueryArray(\"tag\") returns []string{\"go\", \"web\"}\n",
          "code": "func (c *Context) QueryArray(key string) []string"
        },
        {
          "name": "Redirect",
          "doc": "Redirect sends an HTTP redirect to the specified location.\n",
          "code": "func (c *Context) Redirect(code int, location string) *Response"
        },
        {
          "name": "Render",
          "doc": "Render is a helper on Context to render templates using a TemplateRenderer.\nIt sets the response code, handles errors, and ensures the response\nis only written once per request.\n\nParameters:\n  - renderer: the TemplateRenderer to use for rendering\n  - code: HTTP status code for the response\n  - name: template name to render\n  - data: data to pass into the template\n\nReturns a *Response indicating success or failure.\n",
          "code": "func (c *Context) Render(renderer *TemplateRenderer, code int, name string, data interface{}) *Response"
        },
        {
          "name": "Set",
          "doc": "Set stores a value in the Context under the specified key.\nExample: c.Set(\"user\", claims)\n",
          "code": "func (c *Context) Set(key string, value any)"
        },
        {
          "name": "ShouldBind",
          "doc": "ShouldBind attempts to decode the request body into dest based on Content-Type\nwithout automatically writing an error response.\n",
          "code": "func (c *Context) ShouldBind(dest any) error"
        },
        {
          "name": "ShouldBindForm",
          "doc": "ShouldBindForm binds application/x-www-form-urlencoded form values into a struct.\n",
          "code": "func (c *Context) ShouldBindForm(dest any) error"
        },
        {
          "name": "ShouldBindJSON",
          "doc": "ShouldBindJSON decodes JSON without automatic error response.\n",
          "code": "func (c *Context) ShouldBindJSON(dest any) error"
        },
        {
          "name": "ShouldBindMultipart",
          "doc": "ShouldBindMultipart binds multipart form to struct.\n",
          "code": "func (c *Context) ShouldBindMultipart(dest any) error"
        },
        {
          "name": "ShouldBindXML",
          "doc": "ShouldBindXML decodes XML without automatic error response.\n",
          "code": "func (c *Context) ShouldBindXML(dest any) error"
        },
        {
          "name": "String",
          "doc": "String writes plain text and returns a Response\nExample: c.String(200, \"Hello World\")\n",
          "code": "func (c *Context) String(code int, s string) *Response"
        },
        {
          "name": "Validate",
          "doc": "Validate runs validation on the target struct using the stored validator\nIf none exists, it creates a default one on-the-fly\n",
          "code": "func (c *Context) Validate(target any) error"
        }
      ],
      "package": "server",
      "code": "type Context struct {\n\tWriter\t\thttp.ResponseWriter\n\tRequest\t\t*http.Request\n\tParams\t\tmap[string]string\n\tHandled\t\tbool\n\tTemplates\t*TemplateRenderer\n\tValidator\t*validator.Validate\n\tValues\t\tmap[string]any\n}"
    },
    {
      "name": "HandlerFunc",
      "doc": "HandlerFunc defines the signature for all route handlers in Falcon.\nEvery handler receives a pointer to a Context and returns a pointer to a Response.\nThe framework automatically writes the Response as JSON to the client.\n",
      "package": "server",
      "code": "type HandlerFunc func(c *Context) *Response"
    },
    {
      "name": "Response",
      "doc": "Response is the unified return type for all handlers in Falcon.\nIt is automatically serialized to JSON and written to the client.\nFields:\n  - Success: indicates whether the request was successful.\n  - Message: human-readable message describing the result.\n  - Details: optional field containing extra data (any type).\n  - Code: HTTP status code to be sent to the client. It's Required to have at least one Status code\n",
      "package": "server",
      "code": "type Response struct {\n\tSuccess\tbool\t`json:\"success\"`\n\tMessage\tstring\t`json:\"message\"`\n\tDetails\tany\t`json:\"details,omitempty\"`\n\tCode\tint\t`json:\"code\"`\t// required\n}"
    },
    {
      "name": "Router",
      "doc": "Router is a minimal HTTP router that supports method-based routing\nand simple path parameters (e.g., /users/:id).\n",
      "methods": [
        {
          "name": "FindHandler",
          "doc": "FindHandler attempts to match an incoming request (method + path)\nagainst the registered routes. It supports simple path parameters\nlike \"/users/:id\" and extracts them into a map.\nReturns the matching HandlerFunc and a map of extracted params.\nIf no match is found, it returns (nil, nil).\n",
          "code": "func (r *Router) FindHandler(method, path string) (HandlerFunc, map[string]string)"
        },
        {
          "name": "Handle",
          "doc": "Handle registers a new route with a specific HTTP method, path, and handler.\n",
          "code": "func (r *Router) Handle(method, path string, handler HandlerFunc)"
        }
      ],
      "package": "server",
      "code": "type Router struct {\n\t// contains filtered or unexported fields\n}"
    },
    {
      "name": "TemplateRenderer",
      "doc": "TemplateRenderer manages HTML templates for rendering in Falcon.\nIt supports thread-safe access and optional development mode for live reloading.\n",
      "methods": [
        {
          "name": "Render",
          "doc": "Render executes the template with the given name and data, writing\nthe output to the provided http.ResponseWriter.\nIn dev mode, templates are reloaded on each render.\n",
          "code": "func (tr *TemplateRenderer) Render(w http.ResponseWriter, name string, data interface{}) error"
        }
      ],
      "package": "server",
      "code": "type TemplateRenderer struct {\n\t// contains filtered or unexported fields\n}"
    },
    {
      "name": "TestStruct",
      "doc": "",
      "package": "server_test",
      "code": "type TestStruct struct {\n\tName\tstring\t`validate:\"required\"`\n\tEmail\tstring\t`validate:\"required,email\"`\n}"
    }
  ],
  "functions": [
    {
      "name": "NewTemplateRenderer",
      "doc": "NewTemplateRenderer Encapsulates server.NewTemplateRenderer\n",
      "package": "falcon",
      "code": "func NewTemplateRenderer(pattern string, devMode bool, funcs template.FuncMap) *server.TemplateRenderer"
    }
  ]
}